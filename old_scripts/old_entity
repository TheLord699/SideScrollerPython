import pygame as pg
import json
import random
import math
import time
import os

# poor implementation of a class that handles all entities in the game 
# one instance of this class is created in the game class, and it handles all entities in the game
# and should be refactored to have seperate instances for each entity
# will make more OOP friendly and more conventional
# use of ABC and abstract methods would be better
# but for now this is a quick and dirty implementation 
# also was created prior to having this knowledge
class Entities:
    def __init__(self, game):
        self.game = game
        
        self.sounds = {
            "hit": [
                {"sound": pg.mixer.Sound("assets/sounds/entity/21_orc_damage_1.wav"), "volume": 2},
                {"sound": pg.mixer.Sound("assets/sounds/entity/21_orc_damage_2.wav"), "volume": 2},
                {"sound": pg.mixer.Sound("assets/sounds/entity/21_orc_damage_3.wav"), "volume": 2}
            ]
        }
        
        random.seed(self.game.environment.seed)
        
        self.ai_behaviors = {
            "idle": self.ai_idle,
            "wander": self.ai_wander,
            "aggressive": self.ai_aggressive,
            "friendly": self.ai_friendly
        }
        
        self.load_settings()

    def update_ai(self, entity):
        screen_width = self.game.screen.get_width()
        screen_height = self.game.screen.get_height()
        
        if (self.game.player.cam_x <= entity["x"] <= self.game.player.cam_x + screen_width and self.game.player.cam_y <= entity["y"] <= self.game.player.cam_y + screen_height):
            if "behavior" in entity:
                behavior = entity["behavior"]
                if behavior in self.ai_behaviors:
                    self.ai_behaviors[behavior](entity)
    
    def ai_idle(self, entity):
        entity["vel_x"] = 0
    
    def ai_wander(self, entity):
        if "ai_timer" not in entity:
            entity["ai_timer"] = random.randint(60, 180)
            entity["ai_direction"] = random.choice([-1, 0, 1])
        
        entity["ai_timer"] -= 1
        if entity["ai_timer"] <= 0:
            entity["ai_timer"] = random.randint(60, 180)
            entity["ai_direction"] = random.choice([-1, 0, 1])
        
        entity["vel_x"] = entity.get("move_speed", 1) * entity["ai_direction"]
        
        if random.random() < 0.01 and entity.get("on_ground", False):
            entity["vel_y"] = -entity.get("jump_force", 10)
    
    def ai_aggressive(self, entity):
        player = self.game.player
        dx = player.x - entity["x"]
        dy = player.y - entity["y"]
        distance = math.sqrt(dx*dx + dy*dy)
        
        if distance < entity.get("aggro_range", 300):
            entity["ai_direction"] = 1 if dx > 0 else -1
            entity["vel_x"] = entity["ai_direction"] * entity.get("move_speed", 1) * 1.5
            
            if dy < -50 and entity.get("on_ground", False):
                entity["vel_y"] = -entity.get("jump_force", 10)
                
            if distance < 50:
                self.ai_attack(entity)
        else:
            self.ai_wander(entity)
            
    def ai_friendly(self, entity):
        player = self.game.player
        dx = player.x - entity["x"]
        distance = abs(dx)
        
        if distance > 100:
            entity["ai_direction"] = 1 if dx > 0 else -1
            entity["vel_x"] = entity["ai_direction"] * entity.get("move_speed", 1)
        else:
            entity["vel_x"] = 0
            
    def ai_attack(self, entity):
        if "attack_timer" not in entity:
            entity["attack_timer"] = 0

        if entity["attack_timer"] <= 0:
            entity["attack_timer"] = 30

            direction = entity.get("ai_direction", 1)

            hitbox_width = 30
            hitbox_height = 30

            x_offset = 20 if direction > 0 else -hitbox_width - 20
            attack_x = entity["x"] + x_offset
            attack_y = entity["y"] - 10

            attack_rect = pg.Rect(attack_x, attack_y, hitbox_width, hitbox_height)

            if hasattr(self.game, "debug") and self.game.debug:
                pg.draw.rect(self.game.screen, (255, 0, 0), attack_rect, 2)

            if attack_rect.colliderect(self.game.player.hitbox):
                self.game.player.take_damage(entity.get("attack_damage", 10))

        else:
            entity["attack_timer"] -= 1

    def load_entity_info(self):
        with open('assets/settings/entities.json', 'r') as f:
            self.entity_info = json.load(f)

    def load_tilesheet(self, path, tile_width, tile_height):
        self.tilesheet = None
        self.item_sprites.clear()

        if not path or not os.path.exists(path):
            print(f"Tilesheet not found: {path}")
            return

        self.tilesheet = pg.image.load(path).convert_alpha()
        sheet_width, sheet_height = self.tilesheet.get_size()

        for row in range(sheet_height // tile_height):
            for col in range(sheet_width // tile_width):
                rect = pg.Rect(col * tile_width, row * tile_height, tile_width, tile_height)
                sprite = self.tilesheet.subsurface(rect).copy()
                key = f"item_{row}_{col}"
                self.item_sprites[key] = sprite

    def load_settings(self):
        self.x = 0
        self.y = 0
        
        self.width = 0
        self.height = 0
        self.weight = 0
        
        self.health = 0
        
        self.vel_x = 0
        self.vel_y = 0
        
        self.tilesheet = None
        self.scale = self.game.environment.scale 
        
        self.entities = []
        self.entity_info = {}
        self.item_sprites = {}
        
        self.load_entity_info()

    def reset(self):
        self.entities.clear()

    def item(self, item_name):
        if item_name in self.entity_info["items"]:
            return self.entity_info["items"][item_name]
        return None

    def enemy(self, enemy_name):
        if enemy_name in self.entity_info["enemies"]:
            return self.entity_info["enemies"][enemy_name]
        return None

    def npc(self, npc_name):
        if npc_name in self.entity_info["npcs"]:
            return self.entity_info["npcs"][npc_name]
        return None

    def actor(self, actor_name):
        if actor_name in self.entity_info["actors"]:
            return self.entity_info["actors"][actor_name]
        return None
    
    def create_npc(self, npc_name, x, y):
        npc = self.npc(npc_name)
        self.load_tilesheet(npc.get("tile_sheet", None)[0], npc.get("tile_sheet", 0)[1], npc.get("tile_sheet", 0)[2])
        if npc:
            npc_index = npc.get("index", None)
            image = self.item_sprites.get(npc_index, self.game.environment.missing_texture.copy())

            entity = {
                "entity_type": "npc",
                "type": npc.get("type", None),
                "name": npc_name,
                "value": npc.get("value", 0),
                "health": npc.get("health", 0),
                "max_health": npc.get("health", 0),
                "x": x,
                "y": y,
                "width": npc.get("width", 32), 
                "height": npc.get("height", 32), 
                "weight": npc.get("weight", 1),
                "image": image,
                "vel_x": 0,  
                "vel_y": 0,
                "message": npc.get("message", None),
                "behavior": npc.get("behavior", "idle"),
                "move_speed": npc.get("move_speed", 1),
                "jump_force": npc.get("jump_force", 10),
                "aggro_range": npc.get("aggro_range", 300),
                "attack_damage": npc.get("attack_damage", 10),
                "push_force": npc.get("push_force", 20),
            }
            self.entities.append(entity)
    
    def create_item(self, item_name, x, y):
        item = self.item(item_name)
        self.load_tilesheet(item.get("tile_sheet", None)[0], item.get("tile_sheet", 0)[1], item.get("tile_sheet", 0)[2])
        if item:
            item_index = item.get("index", None)
            image = self.item_sprites.get(item_index, self.game.environment.missing_texture.copy())
            
            entity = {
                "entity_type": "item",
                "type": item.get("type", None),
                "name": item_name,
                "quantity": item.get("quantity", 1),
                "value": item.get("value", 0),
                "health": item.get("health", 0),
                "max_health": item.get("health", 0),
                "x": x,
                "y": y,
                "width": item.get("width", 32), 
                "height": item.get("height", 32), 
                "weight": item.get("weight", 1),
                "image": image,
                "vel_x": 0,  
                "vel_y": 0,
                "states": item.get("states", None),
                "current_state": "idle",
                "push_force": item.get("push_force", 20),
            }
            self.entities.append(entity)
        
    def create_actor(self, actor_name, x, y):
        actor = self.actor(actor_name)
        self.load_tilesheet(actor.get("tile_sheet", None)[0], actor.get("tile_sheet", 0)[1], actor.get("tile_sheet", 0)[2])
        if actor:
            item_index = actor.get("index", None)
            image = self.item_sprites.get(item_index, self.game.environment.missing_texture.copy())
            
            entity = {
                "entity_type": "actor",
                "type": actor.get("type", None),
                "name": actor_name,
                "value": actor.get("value", 0),
                "health": actor.get("health", 0),
                "max_health": actor.get("health", 0),
                "x": x,
                "y": y,
                "width": actor.get("width", 32), 
                "height": actor.get("height", 32), 
                "weight": actor.get("weight", 1),
                "image": image,
                "vel_x": 0,  
                "vel_y": 0,
                "states": actor.get("states", None),
                "abilities": actor.get("entity_abilities", None),
                "push_force": actor.get("push_force", 20),
            }
            self.entities.append(entity)

    def create_enemy(self, enemy_name, x, y):
        enemy = self.enemy(enemy_name)
        self.load_tilesheet(enemy.get("tile_sheet", None)[0], enemy.get("tile_sheet", 0)[1], enemy.get("tile_sheet", 0)[2])
        if enemy:
            item_index = enemy.get("index", None)
            image = self.item_sprites.get(item_index, self.game.environment.missing_texture.copy())
            
            entity = {
                "entity_type": "enemy",
                "type": enemy.get("type", None),
                "name": enemy_name,
                "value": enemy.get("value", 0),
                "health": enemy.get("health", 0),
                "max_health": enemy.get("health", 0),
                "x": x,
                "y": y,
                "width": enemy.get("width", 32), 
                "height": enemy.get("height", 32), 
                "weight": enemy.get("weight", 1),
                "image": image,
                "vel_x": 0,  
                "vel_y": 0,
                "states": enemy.get("states", None),
                "abilities": enemy.get("entity_abilities", None),
                "behavior": enemy.get("behavior", "aggressive"),
                "move_speed": enemy.get("move_speed", 1),
                "jump_force": enemy.get("jump_force", 10),
                "aggro_range": enemy.get("aggro_range", 300),
                "attack_damage": enemy.get("attack_damage", 10),
                "push_force": enemy.get("push_force", 20),
            }
            self.entities.append(entity)

    def update_entity(self, entity):
        for sound_group in self.sounds.values():
            if isinstance(sound_group, list):
                for sound_dict in sound_group:
                    sound = sound_dict["sound"]
                    volume = sound_dict["volume"]
                    sound.set_volume(self.game.environment.volume / 10 * volume)
                        
            elif isinstance(sound_group, dict):
                for sound_key, sound_dict in sound_group.items():
                    sound = sound_dict["sound"]
                    volume = sound_dict["volume"]
                    sound.set_volume(self.game.environment.volume / 10 * volume)

        if entity["entity_type"] in {"npc", "enemy"}:
            if entity["health"] <= 0:
                self.entities.remove(entity)
    
    def load_frames(self):
        sprite_sheets = {} 
        
        # temporary from player script
        for state, num_frames in self.state_frames.items():
            if state not in sprite_sheets:  
                sprite_sheets[state] = pg.image.load(f"assets/sprites/player/{state}_animation.png").convert_alpha()
                
            sheet = sprite_sheets[state]
            for frame in range(num_frames["frames"]):
                image = self.get_image(sheet, frame, self.sheet_width, self.sheet_height, self.sheet_width * self.scale_factor, self.sheet_height * self.scale_factor, (0, 0, 0))
                self.frames[state].append(image)

    def get_image(self, sheet, frame, width, height, new_w, new_h, color):
        image = pg.Surface((width, height), pg.SRCALPHA).convert_alpha()
        image.blit(sheet, (0, 0), ((frame * width), 0, width, height))
        image = pg.transform.scale(image, (new_w, new_h))
        image.set_colorkey(color)
        return image
    
    def animate(self):
        pass

    def spawn_hit_particles(self, entity, amount=3):
        for _ in range(amount):
            vel_x = random.uniform(-1.5, 1.5)  
            vel_y = random.uniform(-6.0, -6.5) 
            radius = random.randint(6, 9)

            image_path = "assets/sprites/particles/blood.png"
            particle_img = pg.image.load(image_path).convert_alpha()

            self.game.particles.generate(
                pos=(entity["x"], entity["y"] - entity["height"]),
                velocity=(vel_x, vel_y),
                gravity=0.7,             
                floor_behavior="bounce",   
                color=(255, 50, 50),
                radius=radius,
                lifespan=60,
                fade=True,
                image=particle_img,
                image_size=(radius * 3, radius * 3)
            )

    def update_collision(self, entity):
        entity_hitbox = pg.Rect(entity["x"] - entity["width"] / 2, entity["y"] - entity["height"] / 2, entity["width"], entity["height"])

        for index, tile_hitbox in enumerate(self.game.map.tile_hitboxes):
            tile_id = self.game.map.tile_id[index]
            tile_attributes = self.game.map.tile_attributes.get(tile_id, {})
            swimmable = tile_attributes.get("swimmable", False)

            if entity_hitbox.colliderect(tile_hitbox):
                overlap_x = min(entity_hitbox.right - tile_hitbox.left, tile_hitbox.right - entity_hitbox.left)
                overlap_y = min(entity_hitbox.bottom - tile_hitbox.top, tile_hitbox.bottom - entity_hitbox.top)

                if overlap_x < overlap_y:  
                    if not swimmable:
                        if entity_hitbox.centerx > tile_hitbox.centerx:
                            entity["x"] = tile_hitbox.right + entity["width"] / 2
                            
                        else:
                            entity["x"] = tile_hitbox.left - entity["width"] / 2
                            
                        entity["vel_x"] = -entity["vel_x"] * 0.5

                else:  
                    if entity_hitbox.centery < tile_hitbox.centery:
                        entity["y"] = tile_hitbox.top - entity["height"] / 2
                        entity["vel_y"] = 0
                        entity["on_ground"] = True
                        
                    else:
                        entity["y"] = tile_hitbox.bottom + entity["height"] / 2
                        entity["vel_y"] = 0
                        
        if entity["entity_type"] in {"enemy", "npc"}:
            self.update_ai(entity)
            if entity_hitbox.colliderect(self.game.player.attack_hitbox):
                for attack_id in self.game.player.active_melee_attack_ids:
                    if not entity.get("last_hit_id") == attack_id:
                        if entity["health"] > 0:
                            entity["health"] -= 10
                            entity["last_hit_id"] = attack_id
                            entity["damage_effect"] = 1
                            #time.sleep(0.05) # freeze effect
                            #self.spawn_hit_particles(entity)
                            
                            if entity["entity_type"] == "enemy":
                                if not entity["abilities"] == None and "pushable" in entity["abilities"]:     
                                    direction = pg.Vector2(entity["x"] - self.game.player.x, entity["y"] - self.game.player.y)
                                    
                                    base_force = entity.get("push_force", 20)
                                    weight = max(entity["weight"], 0.1)
                                    push_force = base_force / weight

                                    direction.normalize_ip()
                                    entity["vel_x"] += direction.x * push_force
                                    entity["vel_y"] += direction.y * push_force

                            for sound in self.sounds["hit"]:
                                sound["sound"].stop()

                            random.choice(self.sounds["hit"])["sound"].play()

            for attack_id in self.game.player.active_projectile_attack_ids:
                if not entity.get("last_hit_id") == attack_id:
                    if entity["health"] > 0:
                        entity["health"] -= 10
                        entity["last_hit_id"] = attack_id

                        for sound in self.sounds["hit"]:
                            sound["sound"].stop()

                        hit_sound = random.choice(self.sounds["hit"])
                        hit_sound.play()

                        entity["damage_effect"] = 1
                        
        if entity["entity_type"] in {"actor"}:
            if not entity["abilities"] == None and "pushable" in entity["abilities"]:
                if entity_hitbox.colliderect(self.game.player.attack_hitbox):
                    for attack_id in self.game.player.active_melee_attack_ids:
                        if not entity.get("last_hit_id") == attack_id:
                            entity["last_hit_id"] = attack_id
                            
                            direction = pg.Vector2(entity["x"] - self.game.player.x, entity["y"] - self.game.player.y)
                            
                            base_force = entity.get("push_force", 20)
                            weight = max(entity["weight"], 0.1)
                            push_force = base_force / weight

                            direction.normalize_ip()
                            entity["vel_x"] += direction.x * push_force
                            entity["vel_y"] += direction.y * push_force

            for attack_id in self.game.player.active_projectile_attack_ids:
                if not entity.get("last_hit_id") == attack_id:
                    entity["last_hit_id"] = attack_id
                    
                    direction = pg.Vector2(entity["x"] - self.game.player.x, entity["y"] - self.game.player.y)
                    
                    base_force = attack_id["force"]
                    weight = max(entity["weight"], 0.1)
                    push_force = base_force / weight

                    direction.normalize_ip()
                    entity["vel_x"] += direction.x * push_force
                    entity["vel_y"] += direction.y * push_force
                    
    def apply_gravity(self, entity):
        if not self.is_on_ground(entity):
            step = round(max(1, entity["vel_y"]))
            for _ in range(step):
                entity["y"] += 1
                if self.is_on_ground(entity): 
                    entity["vel_y"] = 0
                    break
            
            entity["vel_y"] += self.game.environment.gravity * entity["weight"]
            
            if entity["vel_y"] > self.game.environment.max_fall_speed:
                entity["vel_y"] = self.game.environment.max_fall_speed 

    def apply_horizontal_movement(self, entity):
        entity["x"] += entity["vel_x"]

        if entity.get("on_ground", False): 
            friction = 0.8 # temporary friction value

            if abs(entity["vel_x"]) > 0.1:
                entity["vel_x"] *= friction 

                if abs(entity["vel_x"]) < 0.1:  
                    entity["vel_x"] = 0

    def is_on_ground(self, entity):
        entity_hitbox = pg.Rect(entity["x"] - entity["width"] / 2, entity["y"] - entity["height"] / 2, entity["width"], entity["height"])

        for tile_hitbox in self.game.map.tile_hitboxes:
            if entity_hitbox.colliderect(tile_hitbox):
                if entity_hitbox.bottom >= tile_hitbox.top:
                    entity["y"] = tile_hitbox.top - entity["height"] / 2
                    entity["vel_y"] = 0
                    entity["on_ground"] = True
                    return True

        entity["on_ground"] = False
        return False
    
    def health_bar(self, entity):
        if entity["health"] <= 0 or entity["health"] == entity["max_health"]:
            return
        
        health_percentage = entity["health"] / entity["max_health"]
        bar_width = entity["width"]
        bar_height = 5
        cam_x, cam_y = self.game.player.cam_x, self.game.player.cam_y
        
        bar_x = entity["x"] - cam_x - bar_width // 2
        bar_y = entity["y"] - cam_y - entity["height"] // 2 - 10
        
        pg.draw.rect(self.game.screen, (255, 0, 0), (bar_x, bar_y, bar_width, bar_height))
        pg.draw.rect(self.game.screen, (0, 255, 0), (bar_x, bar_y, bar_width * health_percentage, bar_height))

    def render(self, entity):
        cam_x, cam_y = self.game.player.cam_x, self.game.player.cam_y
        screen_width, screen_height = self.game.screen.get_size()

        if entity["image"]:
            sprite_x = entity["x"] - cam_x - entity["width"] // 2
            sprite_y = entity["y"] - cam_y - entity["height"] // 2

            if sprite_x + entity["width"] >= 0 and sprite_x <= screen_width and sprite_y + entity["height"] >= 0 and sprite_y <= screen_height:
                if entity.get("damage_effect", 0) > 0:
                    tinted_image = entity["image"].copy()
                    tinted_image.fill((255, 0, 0), special_flags=pg.BLEND_ADD)

                    entity["damage_effect"] -= 0.05
                    if entity["damage_effect"] < 0:
                        entity["damage_effect"] = 0
                        
                else:
                    tinted_image = entity["image"]

                scaled_image = pg.transform.scale(tinted_image, (entity["width"], entity["height"]))

                if entity["entity_type"] in {"npc"}:
                    self.health_bar(entity)
                    if entity["x"] > self.game.player.x:
                        scaled_image = pg.transform.flip(scaled_image, True, False)
                
                elif entity["entity_type"] in {"enemy"}:
                    self.health_bar(entity)
                    if "last_dir" not in entity:
                        entity["last_dir"] = 1
                    
                    if entity["vel_x"] > 0:
                        entity["last_dir"] = 1
                        
                    elif entity["vel_x"] < 0:
                        entity["last_dir"] = -1
                    
                    if entity["last_dir"] == -1:
                        scaled_image = pg.transform.flip(scaled_image, True, False)

                self.game.screen.blit(scaled_image, (sprite_x, sprite_y))

    def mouse_interact(self, entity):
        mouse_x, mouse_y = pg.mouse.get_pos()
        mouse_world_x = mouse_x + self.game.player.cam_x
        mouse_world_y = mouse_y + self.game.player.cam_y
        
        entity_hitbox = pg.Rect(entity["x"] - entity["width"] / 2, entity["y"] - entity["height"] / 2, entity["width"], entity["height"])
        
        hovering = entity_hitbox.collidepoint(mouse_world_x, mouse_world_y)
        mouse_pressed = pg.mouse.get_pressed()[0]
        
        if not hasattr(self, 'dragged_entity'):
            if hovering and mouse_pressed:
                self.dragged_entity = entity
                self.drag_offset_x = entity["x"] - mouse_world_x
                self.drag_offset_y = entity["y"] - mouse_world_y

        if hasattr(self, 'dragged_entity') and self.dragged_entity == entity:
            if mouse_pressed:
                entity["on_ground"] = False
                entity["vel_x"] = 0
                entity["vel_y"] = 0
                entity["x"] = mouse_world_x + self.drag_offset_x
                entity["y"] = mouse_world_y + self.drag_offset_y
                
            else:
                del self.dragged_entity 
                        
    def update(self):
            for entity in self.entities[:]: # using a copy of list, so that the rendering doesnt flicker
                if entity["entity_type"] in ["npc", "enemy"]:
                    self.update_ai(entity)  # Add AI update here
                self.update_collision(entity)
                self.apply_gravity(entity)
                self.apply_horizontal_movement(entity)
                self.update_entity(entity)
                self.render(entity)
                self.mouse_interact(entity)
